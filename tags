!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BF	algorithm/lsmtree/bloomfilter.h	/^}BF;$/;"	t	typeref:struct:__anon10
BIG_CONSTANT	algorithm/lsmtree/bloomfilter.c	25;"	d	file:
BITGET	algorithm/lsmtree/bloomfilter.h	/^inline bool BITGET(char input, char offset){$/;"	f
BITSET	algorithm/lsmtree/bloomfilter.h	/^inline void BITSET(char &input, char offset){$/;"	f
BLOCKSIZE	include/settings.h	14;"	d
BLOCKT	include/settings.h	20;"	d
CC	Makefile	/^CC=gcc$/;"	m
CC	algorithm/lsmtree/Makefile	/^CC=gcc$/;"	m
CC	algorithm/normal/Makefile	/^CC=gcc$/;"	m
CC	lower/posix/Makefile	/^CC=gcc$/;"	m
CHACHESIZE	include/settings.h	28;"	d
CQSIZE	include/lsm_settings.h	11;"	d
CTHREAD	include/lsm_settings.h	10;"	d
DATAR	algorithm/lsmtree/lsmtree.h	13;"	d
DATAW	algorithm/lsmtree/lsmtree.h	14;"	d
ENTRYBIT	include/lsm_settings.h	15;"	d
EPC	include/lsm_settings.h	12;"	d
Entry	algorithm/lsmtree/run_array.h	/^typedef struct Entry{$/;"	s
Entry	algorithm/lsmtree/run_array.h	/^}Entry;$/;"	t	typeref:struct:Entry
FORCE_INLINE	algorithm/lsmtree/bloomfilter.c	7;"	d	file:
FORCE_INLINE	algorithm/lsmtree/bloomfilter.c	9;"	d	file:
FSTYPE	include/settings.h	18;"	d
FS_AGAIN_R_T	include/types.h	7;"	d
FS_DELETE_T	include/types.h	6;"	d
FS_GET_T	include/types.h	4;"	d
FS_SET_T	include/types.h	5;"	d
FS_free	include/FS.c	/^void FS_free(void *ptr,int tag){$/;"	f
FS_malloc	include/FS.c	/^int FS_malloc(void **ptr, int size){$/;"	f
G	include/settings.h	7;"	d
HEADERR	algorithm/lsmtree/lsmtree.h	11;"	d
HEADERW	algorithm/lsmtree/lsmtree.h	12;"	d
Iter	algorithm/lsmtree/run_array.h	/^}Iter;$/;"	t	typeref:struct:iterator
K	include/settings.h	5;"	d
KEYNUM	algorithm/lsmtree/lsmtree.h	9;"	d
KEYT	include/settings.h	19;"	d
LEVELN	include/settings.h	38;"	d
LSM	algorithm/lsmtree/lsmtree.c	/^lsmtree LSM;$/;"	v
M	include/settings.h	6;"	d
MAX_L	algorithm/lsmtree/skiplist.h	6;"	d
MEMORYOBJ	Makefile	/^MEMORYOBJ =\\$/;"	m
MIXED	include/settings.h	/^	MIXED$/;"	e	enum:__anon4
MUTEXLOCK	include/lsm_settings.h	18;"	d
MurmurHash3_x86_32	algorithm/lsmtree/bloomfilter.c	/^void MurmurHash3_x86_32( const void * key, int len,uint32_t seed, void * out )$/;"	f
NOB	include/container.h	/^	uint32_t NOB;$/;"	m	struct:lower_info
NOP	include/container.h	/^	uint32_t NOP;$/;"	m	struct:lower_info
Node	algorithm/lsmtree/run_array.h	/^typedef struct Node{$/;"	s
Node	algorithm/lsmtree/run_array.h	/^}Node;$/;"	t	typeref:struct:Node
OBJS	algorithm/lsmtree/Makefile	/^OBJS :=\\$/;"	m
OBJS	algorithm/normal/Makefile	/^OBJS :=\\$/;"	m
OBJS	lower/posix/Makefile	/^OBJS :=\\$/;"	m
OLDDATA	algorithm/lsmtree/lsmtree.h	10;"	d
P	include/settings.h	9;"	d
PAGESIZE	include/settings.h	12;"	d
PPB	include/container.h	/^	uint32_t PPB;$/;"	m	struct:lower_info
PROB	algorithm/lsmtree/skiplist.h	7;"	d
PTR	include/settings.h	22;"	d
PWD	Makefile	/^PWD=$(pwd)$/;"	m
QSIZE	include/settings.h	25;"	d
RAF	include/lsm_settings.h	8;"	d
RANDGET	include/settings.h	/^	RANDGET,RANDSET,$/;"	e	enum:__anon4
RANDSET	include/settings.h	/^	RANDGET,RANDSET,$/;"	e	enum:__anon4
ROTL32	algorithm/lsmtree/bloomfilter.c	22;"	d	file:
ROTL64	algorithm/lsmtree/bloomfilter.c	23;"	d	file:
SEQGET	include/settings.h	/^	SEQGET,SEQSET,$/;"	e	enum:__anon4
SEQSET	include/settings.h	/^	SEQGET,SEQSET,$/;"	e	enum:__anon4
SIZEFACTOR	include/lsm_settings.h	7;"	d
SOB	include/container.h	/^	uint32_t SOB;$/;"	m	struct:lower_info
SOK	include/container.h	/^	uint32_t SOK;$/;"	m	struct:lower_info
SOP	include/container.h	/^	uint32_t SOP;$/;"	m	struct:lower_info
SYNC	include/settings.h	24;"	d
T	include/settings.h	8;"	d
TARGETOBJ	Makefile	/^TARGETOBJ =\\$/;"	m
TARGETOBJ	algorithm/lsmtree/Makefile	/^TARGETOBJ:=\\$/;"	m
TARGETOBJ	algorithm/normal/Makefile	/^TARGETOBJ:=\\$/;"	m
TARGETOBJ	lower/posix/Makefile	/^TARGETOBJ:=\\$/;"	m
TARGET_ALGO	Makefile	/^TARGET_ALGO=normal$/;"	m
TARGET_LOWER	Makefile	/^TARGET_LOWER=posix$/;"	m
THREADSIZE	include/settings.h	26;"	d
TOTALSIZE	include/settings.h	11;"	d
TS	include/container.h	/^	uint64_t TS;$/;"	m	struct:lower_info
V_PTR	include/settings.h	21;"	d
_LARGEFILE64_SOURCE	lower/posix/posix.c	2;"	d	file:
_NOB	include/settings.h	15;"	d
_NOP	include/settings.h	16;"	d
_PPB	include/settings.h	13;"	d
__BLOOM_H__	algorithm/lsmtree/bloomfilter.h	2;"	d
__H_COMPT__	algorithm/lsmtree/compaction.h	2;"	d
__H_CONTAINER__	include/container.h	2;"	d
__H_FS__	include/FS.h	2;"	d
__H_INTERFACE_H	interface/interface.h	2;"	d
__H_QUEUE__	algorithm/lsmtree/c_queue.h	2;"	d
__H_QUEUE__	interface/queue.h	2;"	d
__H_SETLSM__	include/lsm_settings.h	2;"	d
__H_SETTING__	include/settings.h	2;"	d
__H_TYPES__	include/types.h	2;"	d
__LSM_HEADER__	algorithm/lsmtree/lsmtree.h	2;"	d
__RUN_A_H__	algorithm/lsmtree/run_array.h	2;"	d
__SKIPLIST_HEADER	algorithm/lsmtree/skiplist.h	2;"	d
__normal	algorithm/normal/normal.c	/^struct algorithm __normal={$/;"	v	typeref:struct:algorithm
__posix	lower/posix/posix.c	/^lower_info __posix={$/;"	v
_fd	lower/posix/posix.c	/^static int _fd;$/;"	v	file:
algo	interface/threading.h	/^	algorithm *algo;$/;"	m	struct:master_processor
algo_body	include/container.h	/^	void *algo_body;$/;"	m	struct:algorithm
algo_lsm	algorithm/lsmtree/lsmtree.c	/^struct algorithm algo_lsm={$/;"	v	typeref:struct:algorithm
algo_req	include/container.h	/^struct algo_req{$/;"	s
algo_req	include/container.h	/^typedef struct algo_req algo_req;$/;"	t	typeref:struct:algo_req
algorithm	include/container.h	/^struct algorithm{$/;"	s
algorithm	include/container.h	/^typedef struct algorithm algorithm;$/;"	t	typeref:struct:algorithm
assign_req	interface/interface.c	/^static void assign_req(request* req){$/;"	f	file:
async_mutex	include/container.h	/^	pthread_mutex_t async_mutex;$/;"	m	struct:request
bench_clean	bench/bench.c	/^void bench_clean(){$/;"	f
bench_init	bench/bench.c	/^void bench_init(bench_type type, int start, int end, int number){$/;"	f
bench_type	include/settings.h	/^}bench_type;$/;"	t	typeref:enum:__anon4
bench_value	bench/bench.h	/^}bench_value;$/;"	t	typeref:struct:__anon1
bf_bits	algorithm/lsmtree/bloomfilter.c	/^uint64_t bf_bits(int entry, double fpr){$/;"	f
bf_check	algorithm/lsmtree/bloomfilter.c	/^bool bf_check(BF* input, KEYT key){$/;"	f
bf_free	algorithm/lsmtree/bloomfilter.c	/^void bf_free(BF *input){$/;"	f
bf_init	algorithm/lsmtree/bloomfilter.c	/^BF* bf_init(int entry, double fpr){$/;"	f
bf_set	algorithm/lsmtree/bloomfilter.c	/^void bf_set(BF *input, KEYT key){$/;"	f
bitset	algorithm/lsmtree/lsmtree.h	/^	uint8_t bitset[KEYN\/8];$/;"	m	struct:__anon7
bitset	algorithm/lsmtree/run_array.h	/^	uint8_t bitset[KEYN\/8];$/;"	m	struct:Entry
block_bad	include/types.h	/^	block_bad,$/;"	e	enum:__anon5
block_empty	include/types.h	/^	block_empty,$/;"	e	enum:__anon5
block_full	include/types.h	/^	block_full,$/;"	e	enum:__anon5
block_he	include/types.h	/^	block_he$/;"	e	enum:__anon5
body	algorithm/lsmtree/bloomfilter.h	/^	char *body;$/;"	m	struct:__anon10
body	algorithm/lsmtree/run_array.h	/^	char *body;$/;"	m	struct:Node
body	algorithm/lsmtree/run_array.h	/^	char *body;$/;"	m	struct:level
body	bench/bench.c	/^bench_value *body;$/;"	v
body	bench/bench.h	/^	bench_value *body;$/;"	m	struct:__anon2
body_addr	algorithm/lsmtree/run_array.h	/^	char **body_addr;$/;"	m	struct:Node
bool	algorithm/lsmtree/skiplist.h	/^typedef enum {false, true} bool;$/;"	t	typeref:enum:__anon11
bool	include/settings.h	/^typedef enum{false,true} bool;$/;"	t	typeref:enum:__anon3
c_node	algorithm/lsmtree/c_queue.h	/^}c_node;$/;"	t	typeref:struct:node
c_queue	algorithm/lsmtree/c_queue.h	/^}c_queue;$/;"	t	typeref:struct:queue
comp	algorithm/lsmtree/compaction.c	/^int comp (const void * elem1, const void * elem2) {$/;"	f
compM	algorithm/lsmtree/compaction.h	/^typedef struct compaction_master compM;$/;"	t	typeref:struct:compaction_master
compP	algorithm/lsmtree/compaction.h	/^typedef struct compaction_processor compP;$/;"	t	typeref:struct:compaction_processor
compR	algorithm/lsmtree/compaction.h	/^typedef struct compaction_req compR;$/;"	t	typeref:struct:compaction_req
comp_target_get_cnt	algorithm/lsmtree/lsmtree.c	/^int comp_target_get_cnt=0;$/;"	v
compactino_target_cnt	algorithm/lsmtree/compaction.c	/^int compactino_target_cnt;$/;"	v
compaction_assign	algorithm/lsmtree/compaction.c	/^void compaction_assign(compR* req){$/;"	f
compaction_check	algorithm/lsmtree/compaction.c	/^void compaction_check(){$/;"	f
compaction_data_write	algorithm/lsmtree/compaction.c	/^htable *compaction_data_write(skiplist *mem){$/;"	f
compaction_free	algorithm/lsmtree/compaction.c	/^void compaction_free(){$/;"	f
compaction_htable_convert	algorithm/lsmtree/compaction.c	/^htable *compaction_htable_convert(skiplist *input,float fpr){$/;"	f
compaction_htable_read	algorithm/lsmtree/compaction.c	/^void compaction_htable_read(Entry *ent,V_PTR value){$/;"	f
compaction_htable_write	algorithm/lsmtree/compaction.c	/^KEYT compaction_htable_write(htable *input){$/;"	f
compaction_init	algorithm/lsmtree/compaction.c	/^bool compaction_init(){$/;"	f
compaction_main	algorithm/lsmtree/compaction.c	/^void *compaction_main(void *input){$/;"	f
compaction_master	algorithm/lsmtree/compaction.h	/^struct compaction_master{$/;"	s
compaction_processor	algorithm/lsmtree/compaction.h	/^struct compaction_processor{$/;"	s
compaction_read_wait	algorithm/lsmtree/compaction.c	/^void compaction_read_wait(int param){$/;"	f
compaction_req	algorithm/lsmtree/compaction.h	/^struct compaction_req{$/;"	s
compaction_subprocessing	algorithm/lsmtree/compaction.c	/^void compaction_subprocessing(skiplist *target,level *t, htable* datas,bool final,bool existIgnore){$/;"	f
compaction_subprocessing_CMI	algorithm/lsmtree/compaction.c	/^void compaction_subprocessing_CMI(skiplist * target,level * t,bool final){$/;"	f
compaction_wait	algorithm/lsmtree/compaction.c	/^pthread_mutex_t compaction_wait;$/;"	v
compactor	algorithm/lsmtree/compaction.c	/^compM compactor;$/;"	v
cq_dequeue	algorithm/lsmtree/c_queue.c	/^const compR * cq_dequeue(c_queue *q){$/;"	f
cq_enqueue	algorithm/lsmtree/c_queue.c	/^bool cq_enqueue(const compR* req, c_queue* q){$/;"	f
cq_free	algorithm/lsmtree/c_queue.c	/^void cq_free(queue* q){$/;"	f
cq_init	algorithm/lsmtree/c_queue.c	/^void cq_init(c_queue **q){$/;"	f
create	include/container.h	/^	uint32_t (*create) (lower_info*,struct algorithm *);$/;"	m	struct:algorithm
create	include/container.h	/^	uint32_t (*create)(struct lower_info*);$/;"	m	struct:lower_info
destroy	include/container.h	/^	void (*destroy) (lower_info*, struct algorithm *);$/;"	m	struct:algorithm
destroy	include/container.h	/^	void* (*destroy)(struct lower_info*);$/;"	m	struct:lower_info
disk	algorithm/lsmtree/lsmtree.h	/^	level *disk[LEVELN];$/;"	m	struct:__anon9
e_size	algorithm/lsmtree/run_array.h	/^	int e_size;$/;"	m	struct:Node
end	algorithm/lsmtree/run_array.h	/^	KEYT end;$/;"	m	struct:Entry
end	algorithm/lsmtree/run_array.h	/^	KEYT end;$/;"	m	struct:level
end	algorithm/lsmtree/run_array.h	/^	int end;$/;"	m	struct:Node
end_req	include/container.h	/^	bool (*end_req)(const struct request*);$/;"	m	struct:request
end_req	include/container.h	/^	void *(*end_req)(struct algo_req *);$/;"	m	struct:algo_req
entry_p_run	algorithm/lsmtree/run_array.h	/^	int entry_p_run;$/;"	m	struct:level
epc_check	algorithm/lsmtree/compaction.c	/^int epc_check=0;$/;"	v
false	algorithm/lsmtree/skiplist.h	/^typedef enum {false, true} bool;$/;"	e	enum:__anon11
false	include/settings.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
filter	algorithm/lsmtree/lsmtree.h	/^	BF* filter;$/;"	m	struct:__anon7
flag	algorithm/lsmtree/compaction.h	/^	pthread_mutex_t flag;$/;"	m	struct:compaction_processor
flag	algorithm/lsmtree/run_array.h	/^	bool flag;$/;"	m	struct:iterator
flag	interface/threading.h	/^	pthread_mutex_t flag;$/;"	m	struct:master_processor
flag	interface/threading.h	/^	pthread_mutex_t flag;$/;"	m	struct:processor
fmix32	algorithm/lsmtree/bloomfilter.c	/^static FORCE_INLINE uint32_t fmix32 ( uint32_t h )$/;"	f	file:
fmix64	algorithm/lsmtree/bloomfilter.c	/^static FORCE_INLINE uint64_t fmix64 ( uint64_t k )$/;"	f	file:
fpr	algorithm/lsmtree/run_array.h	/^	float fpr;$/;"	m	struct:level
free_bench_all	bench/bench.c	/^void free_bench_all(){$/;"	f
free_bench_one	bench/bench.c	/^void free_bench_one(bench_value*){$/;"	f
fromL	algorithm/lsmtree/compaction.h	/^	int fromL;$/;"	m	struct:compaction_req
get	include/container.h	/^	uint32_t (*get)(const request *);$/;"	m	struct:algorithm
getLevel	algorithm/lsmtree/skiplist.c	/^static int getLevel(){$/;"	f	file:
get_bench	bench/bench.c	/^bench_value* get_bench(){$/;"	f
getblock	algorithm/lsmtree/bloomfilter.c	31;"	d	file:
hashfunction	algorithm/lsmtree/bloomfilter.c	/^KEYT hashfunction(KEYT key){$/;"	f
head	algorithm/lsmtree/c_queue.h	/^	c_node *head;$/;"	m	struct:queue
head	interface/queue.h	/^	node *head;$/;"	m	struct:queue
header	algorithm/lsmtree/skiplist.h	/^	snode *header;$/;"	m	struct:skiplist
htable	algorithm/lsmtree/lsmtree.h	/^}htable;$/;"	t	typeref:struct:__anon7
idx	algorithm/lsmtree/compaction.c	/^	int idx;$/;"	m	struct:temp_ndr	file:
idx	algorithm/lsmtree/run_array.h	/^	int idx;$/;"	m	struct:iterator
inf_end_req	interface/interface.c	/^bool inf_end_req(const request *req){$/;"	f
inf_free	interface/interface.c	/^void inf_free(){$/;"	f
inf_init	interface/interface.c	/^void inf_init(){$/;"	f
inf_make_req	interface/interface.c	/^bool inf_make_req(const FSTYPE type, const KEYT key, const V_PTR value){$/;"	f
inf_make_req_Async	interface/interface.c	/^bool inf_make_req_Async(void *ureq, void *(*end_req)(void*)){$/;"	f
inf_print_debug	interface/interface.c	/^void inf_print_debug(){$/;"	f
isAsync	include/container.h	/^	bool isAsync;$/;"	m	struct:request
isTiering	algorithm/lsmtree/run_array.h	/^	bool isTiering;$/;"	m	struct:level
isvalid	algorithm/lsmtree/skiplist.h	/^	bool isvalid;$/;"	m	struct:snode
iterator	algorithm/lsmtree/run_array.h	/^typedef struct iterator{$/;"	s
k	algorithm/lsmtree/bloomfilter.h	/^	int k;$/;"	m	struct:__anon10
key	algorithm/lsmtree/run_array.h	/^	KEYT key;$/;"	m	struct:Entry
key	algorithm/lsmtree/skiplist.h	/^	KEYT key;$/;"	m	struct:snode
key	bench/bench.h	/^	KEYT key;$/;"	m	struct:__anon1
key	include/container.h	/^	KEYT key;$/;"	m	struct:request
key	include/container.h	/^	const KEYT key; $/;"	m	struct:upper_request
keyset	algorithm/lsmtree/lsmtree.h	/^}keyset;$/;"	t	typeref:struct:__anon6
lev	algorithm/lsmtree/run_array.h	/^	level *lev;$/;"	m	struct:iterator
leve_addr	algorithm/lsmtree/lsmtree.h	/^	PTR leve_addr[LEVEN];$/;"	m	struct:__anon9
level	algorithm/lsmtree/run_array.h	/^typedef struct level{$/;"	s
level	algorithm/lsmtree/run_array.h	/^}level;$/;"	t	typeref:struct:level
level	algorithm/lsmtree/skiplist.h	/^	uint8_t level;$/;"	m	struct:skiplist
level	algorithm/lsmtree/skiplist.h	/^	uint8_t level;$/;"	m	struct:snode
level_check_overlap	algorithm/lsmtree/run_array.c	/^bool level_check_overlap(level *input ,KEYT start, KEYT end){$/;"	f
level_clear	algorithm/lsmtree/run_array.c	/^level *level_clear(level *input){$/;"	f
level_entcpy	algorithm/lsmtree/run_array.c	/^Entry *level_entcpy(Entry *src, char *des){$/;"	f
level_find	algorithm/lsmtree/run_array.c	/^Entry **level_find(level *input,KEYT key){$/;"	f
level_find_fromR	algorithm/lsmtree/run_array.c	/^Entry *level_find_fromR(Node *run, KEYT key){$/;"	f
level_free	algorithm/lsmtree/run_array.c	/^void level_free(level *input){$/;"	f
level_full_check	algorithm/lsmtree/run_array.c	/^bool level_full_check(level *input){$/;"	f
level_get_Iter	algorithm/lsmtree/run_array.c	/^Iter *level_get_Iter(level *input){$/;"	f
level_get_next	algorithm/lsmtree/run_array.c	/^Entry *level_get_next(Iter * input){$/;"	f
level_init	algorithm/lsmtree/run_array.c	/^level *level_init(level *input,int all_entry,bool isTiering){$/;"	f
level_insert	algorithm/lsmtree/run_array.c	/^Node *level_insert(level *input,Entry *entry){\/\/always sequential$/;"	f
level_lock	algorithm/lsmtree/run_array.h	/^	pthread_mutex_t level_lock;$/;"	m	struct:level
level_make_entry	algorithm/lsmtree/run_array.c	/^Entry *level_make_entry(KEYT key,KEYT end,KEYT pbn){$/;"	f
level_print	algorithm/lsmtree/run_array.c	/^void level_print(level *input){$/;"	f
leveling	algorithm/lsmtree/compaction.c	/^uint32_t leveling(int from, int to, Entry *entry){$/;"	f
li	algorithm/lsmtree/lsmtree.h	/^	lower_info* li;$/;"	m	struct:__anon9
li	include/container.h	/^	lower_info* li;$/;"	m	struct:algorithm
li	interface/threading.h	/^	lower_info *li;$/;"	m	struct:master_processor
list	algorithm/lsmtree/skiplist.h	/^	skiplist *list;$/;"	m	struct:__anon12
list	algorithm/lsmtree/skiplist.h	/^	struct snode **list;$/;"	m	struct:snode	typeref:struct:snode::snode
lock	algorithm/lsmtree/lsmtree.h	/^	pthread_mutex_t lock;$/;"	m	struct:__anon8
lower_info	include/container.h	/^struct lower_info {$/;"	s
lower_info	include/container.h	/^typedef struct lower_info lower_info;$/;"	t	typeref:struct:lower_info
lower_status	include/types.h	/^}lower_status;$/;"	t	typeref:enum:__anon5
lpa	algorithm/lsmtree/lsmtree.h	/^	KEYT lpa;$/;"	m	struct:__anon6
lsm_create	algorithm/lsmtree/lsmtree.c	/^uint32_t lsm_create(lower_info *li, algorithm *lsm){$/;"	f
lsm_destroy	algorithm/lsmtree/lsmtree.c	/^void lsm_destroy(lower_info *li, algorithm *lsm){$/;"	f
lsm_end_req	algorithm/lsmtree/lsmtree.c	/^void* lsm_end_req(algo_req* req){$/;"	f
lsm_get	algorithm/lsmtree/lsmtree.c	/^uint32_t lsm_get(const request *req){$/;"	f
lsm_params	algorithm/lsmtree/lsmtree.h	/^}lsm_params;$/;"	t	typeref:struct:__anon8
lsm_remove	algorithm/lsmtree/lsmtree.c	/^uint32_t lsm_remove(const request *req){$/;"	f
lsm_set	algorithm/lsmtree/lsmtree.c	/^uint32_t lsm_set(const request *req){$/;"	f
lsm_type	algorithm/lsmtree/lsmtree.h	/^	uint8_t lsm_type;$/;"	m	struct:__anon8
lsmtree	algorithm/lsmtree/lsmtree.h	/^}lsmtree;$/;"	t	typeref:struct:__anon9
m	algorithm/lsmtree/bloomfilter.h	/^	int m;$/;"	m	struct:__anon10
m_num	algorithm/lsmtree/run_array.h	/^	int m_num;$/;"	m	struct:Node
m_num	algorithm/lsmtree/run_array.h	/^	int m_num;\/\/number of entries$/;"	m	struct:level
main	interface/main.c	/^int main(){$/;"	f
make_temp_req	interface/interface.c	/^static request* make_temp_req(const FSTYPE type, const KEYT key, const V_PTR value,request *cpy){$/;"	f	file:
master	algorithm/lsmtree/compaction.h	/^	compM *master;$/;"	m	struct:compaction_processor
master	interface/threading.h	/^	master_processor *master;$/;"	m	struct:processor
master_processor	interface/threading.h	/^struct master_processor{$/;"	s
master_processor	interface/threading.h	/^typedef struct master_processor master_processor;$/;"	t	typeref:struct:master_processor
memtable	algorithm/lsmtree/lsmtree.h	/^	skiplist *memtable;$/;"	m	struct:__anon9
monitor	bench/bench.h	/^}monitor;$/;"	t	typeref:struct:__anon2
mp	interface/interface.c	/^master_processor mp;$/;"	v
n	algorithm/lsmtree/bloomfilter.h	/^	int n;$/;"	m	struct:__anon10
n_num	algorithm/lsmtree/run_array.h	/^	int n_num;$/;"	m	struct:Node
n_num	algorithm/lsmtree/run_array.h	/^	int n_num;$/;"	m	struct:level
ndr	algorithm/lsmtree/compaction.c	/^}ndr;$/;"	t	typeref:struct:temp_ndr	file:
next	algorithm/lsmtree/c_queue.h	/^	struct c_node *next;$/;"	m	struct:node	typeref:struct:node::c_node
next	interface/queue.h	/^	struct node *next;$/;"	m	struct:node	typeref:struct:node::node
node	algorithm/lsmtree/c_queue.h	/^typedef struct node{$/;"	s
node	interface/queue.h	/^typedef struct node{$/;"	s
node	interface/queue.h	/^}node;$/;"	t	typeref:struct:node
normal_create	algorithm/normal/normal.c	/^uint32_t normal_create (lower_info* li,algorithm *algo){$/;"	f
normal_destroy	algorithm/normal/normal.c	/^void normal_destroy (lower_info* li, algorithm *algo){$/;"	f
normal_end_req	algorithm/normal/normal.c	/^void *normal_end_req(algo_req* input){$/;"	f
normal_get	algorithm/normal/normal.c	/^uint32_t normal_get(const request *req){$/;"	f
normal_params	algorithm/normal/normal.h	/^typedef struct normal_params{$/;"	s
normal_params	algorithm/normal/normal.h	/^}normal_params;$/;"	t	typeref:struct:normal_params
normal_remove	algorithm/normal/normal.c	/^bool normal_remove(const request *req){$/;"	f
normal_set	algorithm/normal/normal.c	/^bool normal_set(const request *req){$/;"	f
now	algorithm/lsmtree/run_array.h	/^	Node *now;$/;"	m	struct:iterator
now	algorithm/lsmtree/skiplist.h	/^	snode *now;$/;"	m	struct:__anon12
ns_entry	algorithm/lsmtree/run_array.c	/^Entry *ns_entry(Node *input, int n){$/;"	f
ns_run	algorithm/lsmtree/run_array.c	/^Node *ns_run(level*input ,int n){$/;"	f
p	algorithm/lsmtree/bloomfilter.h	/^	double p;$/;"	m	struct:__anon10
p_main	interface/interface.c	/^void *p_main(void *__input){$/;"	f
params	include/container.h	/^	void *params;$/;"	m	struct:algo_req
params	include/container.h	/^	void *params;$/;"	m	struct:request
parents	algorithm/normal/normal.h	/^	request *parents;$/;"	m	struct:normal_params
partial_leveling	algorithm/lsmtree/compaction.c	/^uint32_t partial_leveling(level* t,level *origin,skiplit *skip,bool final){$/;"	f
partial_tiering	algorithm/lsmtree/compaction.c	/^uint64_t partial_tiering(level *t,level *f, skiplist* skip, int *runtable){$/;"	f
pbn	algorithm/lsmtree/run_array.h	/^	KEYT pbn;$/;"	m	struct:Entry
posix_create	lower/posix/posix.c	/^uint32_t posix_create(lower_info *li){$/;"	f
posix_destroy	lower/posix/posix.c	/^void *posix_destroy(lower_info *li){$/;"	f
posix_pull_data	lower/posix/posix.c	/^void *posix_pull_data(KEYT PPA, uint32_t size, const V_PTR value, bool async,const algo_req *req, uint32_t dmatag){$/;"	f
posix_push_data	lower/posix/posix.c	/^void *posix_push_data(KEYT PPA, uint32_t size, const V_PTR value, bool async,const algo_req *req, uint32_t dmatag){$/;"	f
posix_stop	lower/posix/posix.c	/^void posix_stop(){}$/;"	f
posix_trim_block	lower/posix/posix.c	/^void *posix_trim_block(KEYT PPA, bool async){$/;"	f
ppa	algorithm/lsmtree/lsmtree.h	/^	KEYT ppa;$/;"	m	struct:__anon6
ppa	algorithm/lsmtree/skiplist.h	/^	KEYT ppa;$/;"	m	struct:snode
processor	interface/threading.h	/^typedef struct processor{$/;"	s
processor	interface/threading.h	/^}processor;$/;"	t	typeref:struct:processor
processors	algorithm/lsmtree/compaction.h	/^	compP *processors;$/;"	m	struct:compaction_master
processors	interface/threading.h	/^	processor *processors;$/;"	m	struct:master_processor
pull_data	include/container.h	/^	void* (*pull_data)(KEYT ppa, uint32_t size, const V_PTR value,bool async,const algo_req* req,uint32_t dmatag);$/;"	m	struct:lower_info
push_data	include/container.h	/^	void* (*push_data)(KEYT ppa, uint32_t size, const V_PTR value,bool async,const algo_req* req,uint32_t dmatag);$/;"	m	struct:lower_info
q	algorithm/lsmtree/compaction.h	/^	c_queue *q;$/;"	m	struct:compaction_processor
q_dequeue	interface/queue.c	/^const request * q_dequeue(queue *q){$/;"	f
q_enqueue	interface/queue.c	/^bool q_enqueue(const request* req, queue* q){$/;"	f
q_free	interface/queue.c	/^void q_free(queue* q){$/;"	f
q_init	interface/queue.c	/^void q_init(queue **q){$/;"	f
q_lock	algorithm/lsmtree/c_queue.h	/^	pthread_mutex_t q_lock;$/;"	m	struct:queue
q_lock	interface/queue.h	/^	pthread_mutex_t q_lock;$/;"	m	struct:queue
queue	algorithm/lsmtree/c_queue.h	/^typedef struct queue{$/;"	s
queue	interface/queue.h	/^typedef struct queue{$/;"	s
queue	interface/queue.h	/^}queue;$/;"	t	typeref:struct:queue
r_idx	algorithm/lsmtree/run_array.h	/^	int r_idx;$/;"	m	struct:iterator
r_n_num	algorithm/lsmtree/run_array.h	/^	int r_n_num;$/;"	m	struct:level
r_num	algorithm/lsmtree/run_array.h	/^	int r_num;$/;"	m	struct:level
r_size	algorithm/lsmtree/run_array.h	/^	int r_size;\/\/size of run$/;"	m	struct:level
r_type	interface/interface.c	/^const FSTYPE r_type=FS_GET_T;$/;"	v
remove	include/container.h	/^	uint32_t (*remove)(const request*);$/;"	m	struct:algorithm
req	algorithm/lsmtree/c_queue.h	/^	const compR *req;$/;"	m	struct:node
req	algorithm/lsmtree/lsmtree.h	/^	const request *req;$/;"	m	struct:__anon8
req	algorithm/lsmtree/skiplist.h	/^	struct algo_req *req;$/;"	m	struct:snode	typeref:struct:snode::algo_req
req	interface/queue.h	/^	const request *req;$/;"	m	struct:node
req_q	interface/threading.h	/^	queue *req_q;$/;"	m	struct:processor
request	include/container.h	/^struct request {$/;"	s
request	include/container.h	/^typedef struct request request;$/;"	t	typeref:struct:request
rotl32	algorithm/lsmtree/bloomfilter.c	/^static FORCE_INLINE uint32_t rotl32 ( uint32_t x, int8_t r )$/;"	f	file:
rotl64	algorithm/lsmtree/bloomfilter.c	/^static FORCE_INLINE uint64_t rotl64 ( uint64_t x, int8_t r )$/;"	f	file:
s_num	algorithm/lsmtree/compaction.c	/^	int	s_num;$/;"	m	struct:temp_ndr	file:
seqget	bench/bench.c	/^void seqget(int start, int end, int number){$/;"	f
seqset	bench/bench.c	/^void seqset(int start, int end, int number){$/;"	f
set	include/container.h	/^	uint32_t (*set)(const request *);$/;"	m	struct:algorithm
sets	algorithm/lsmtree/lsmtree.h	/^	keyset sets[KEYNUM];$/;"	m	struct:__anon7
size	algorithm/lsmtree/c_queue.h	/^	int size;$/;"	m	struct:queue
size	algorithm/lsmtree/run_array.h	/^	int size;$/;"	m	struct:level
size	algorithm/lsmtree/skiplist.h	/^	uint64_t size;$/;"	m	struct:skiplist
size	interface/queue.h	/^	int size;$/;"	m	struct:queue
sk_iter	algorithm/lsmtree/skiplist.h	/^} sk_iter;$/;"	t	typeref:struct:__anon12
skiplist	algorithm/lsmtree/skiplist.h	/^typedef struct skiplist{$/;"	s
skiplist	algorithm/lsmtree/skiplist.h	/^}skiplist;$/;"	t	typeref:struct:skiplist
skiplist_at	algorithm/lsmtree/skiplist.c	/^snode *skiplist_at(skiplist *list, int idx){$/;"	f
skiplist_clear	algorithm/lsmtree/skiplist.c	/^void skiplist_clear(skiplist *list){$/;"	f
skiplist_cut	algorithm/lsmtree/skiplist.c	/^skiplsit *skiplist_cut(skiplist *list, int size){$/;"	f
skiplist_delete	algorithm/lsmtree/skiplist.c	/^int skiplist_delete(skiplist* list, KEYT key){$/;"	f
skiplist_dump	algorithm/lsmtree/skiplist.c	/^void skiplist_dump(skiplist * list){$/;"	f
skiplist_find	algorithm/lsmtree/skiplist.c	/^snode *skiplist_find(skiplist *list, KEYT key){$/;"	f
skiplist_free	algorithm/lsmtree/skiplist.c	/^void skiplist_free(skiplist *list){$/;"	f
skiplist_get_iterator	algorithm/lsmtree/skiplist.c	/^sk_iter* skiplist_get_iterator(skiplist *list){$/;"	f
skiplist_get_next	algorithm/lsmtree/skiplist.c	/^snode *skiplist_get_next(sk_iter* iter){$/;"	f
skiplist_init	algorithm/lsmtree/skiplist.c	/^skiplist *skiplist_init(){$/;"	f
skiplist_insert	algorithm/lsmtree/skiplist.c	/^snode *skiplist_insert(skiplist *list,KEYT key, char *value, algo_req *req,bool deletef){$/;"	f
skiplist_insert_wP	algorithm/lsmtree/skiplist.c	/^snode *skiplist_insert_wP(skiplist *list, KEYT key, KEYT ppa,bool deletef){$/;"	f
skiplist_insert_wp_existIgnore	algorithm/lsmtree/skiplist.c	/^snode *skiplist_insert_wp_existIgnore(skiplist *list,KEYT key,KEYT ppa,bool deletef){$/;"	f
skiplist_pop	algorithm/lsmtree/skiplist.c	/^snode *skiplist_pop(skiplist *list){$/;"	f
snode	algorithm/lsmtree/skiplist.h	/^typedef struct snode{ \/\/skiplist's node$/;"	s
snode	algorithm/lsmtree/skiplist.h	/^}snode;$/;"	t	typeref:struct:snode
start	algorithm/lsmtree/run_array.h	/^	KEYT start;$/;"	m	struct:level
start	algorithm/lsmtree/run_array.h	/^	int start;$/;"	m	struct:Node
statusOfblock	include/container.h	/^	lower_status (*statusOfblock)(BLOCKT);$/;"	m	struct:lower_info
stop	include/container.h	/^	void (*stop)();$/;"	m	struct:lower_info
stopflag	algorithm/lsmtree/compaction.h	/^	bool stopflag;$/;"	m	struct:compaction_master
stopflag	interface/threading.h	/^	bool stopflag;$/;"	m	struct:master_processor
t_id	algorithm/lsmtree/compaction.h	/^	pthread_t t_id;$/;"	m	struct:compaction_processor
t_id	interface/threading.h	/^	pthread_t t_id;$/;"	m	struct:processor
t_skip	algorithm/lsmtree/run_array.h	/^	skiplist *t_skip;$/;"	m	struct:Entry
t_table	algorithm/lsmtree/run_array.h	/^	htable *t_table;$/;"	m	struct:Entry
tail	algorithm/lsmtree/c_queue.h	/^	c_node *tail;$/;"	m	struct:queue
tail	interface/queue.h	/^	node *tail;$/;"	m	struct:queue
targetsize	algorithm/lsmtree/bloomfilter.h	/^	int targetsize;$/;"	m	struct:__anon10
temp_ndr	algorithm/lsmtree/compaction.c	/^typedef struct temp_ndr{$/;"	s	file:
temp_ppa	algorithm/lsmtree/compaction.c	/^uint64_t temp_ppa;$/;"	v
temptable	algorithm/lsmtree/lsmtree.h	/^	skiplist *temptable;$/;"	m	struct:__anon9
test	algorithm/normal/normal.h	/^	int test;$/;"	m	struct:normal_params
tiering	algorithm/lsmtree/compaction.c	/^uint32_t tiering(int from, int to, Entry *entry){$/;"	f
toL	algorithm/lsmtree/compaction.h	/^	int toL;$/;"	m	struct:compaction_req
trim_block	include/container.h	/^	void* (*trim_block)(KEYT ppa,bool async);$/;"	m	struct:lower_info
true	algorithm/lsmtree/skiplist.h	/^typedef enum {false, true} bool;$/;"	e	enum:__anon11
true	include/settings.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
type	bench/bench.h	/^	FSTYPE type;$/;"	m	struct:__anon1
type	include/container.h	/^	FSTYPE type;$/;"	m	struct:request
type	include/container.h	/^	const FSTYPE type;$/;"	m	struct:upper_request
upper_end	include/container.h	/^	void *(*upper_end)(void *);$/;"	m	struct:request
upper_req	include/container.h	/^	void *upper_req;$/;"	m	struct:request
upper_request	include/container.h	/^typedef struct upper_request{$/;"	s
upper_request	include/container.h	/^}upper_request;$/;"	t	typeref:struct:upper_request
v_entry	algorithm/lsmtree/run_array.h	/^	Entry *v_entry;$/;"	m	struct:iterator
value	algorithm/lsmtree/lsmtree.h	/^	V_PTR value;$/;"	m	struct:__anon8
value	algorithm/lsmtree/skiplist.h	/^	V_PTR *value;$/;"	m	struct:snode
value	bench/bench.h	/^	V_PTR value;$/;"	m	struct:__anon1
value	include/container.h	/^	V_PTR value;$/;"	m	struct:request
value	include/container.h	/^	const V_PTR value;$/;"	m	struct:upper_request
version	algorithm/lsmtree/run_array.h	/^	uint64_t version;$/;"	m	struct:Entry
